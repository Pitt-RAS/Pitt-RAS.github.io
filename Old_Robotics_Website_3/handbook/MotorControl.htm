<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://scheinman.org/Example_PIC_code/MotorControl/ -->
<HTML><HEAD><TITLE>Motor Control</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK
href="Motor Control_files/lesson_style.css" rel=stylesheet>
<META content="MSHTML 6.00.2800.1226" name=GENERATOR></HEAD>
<BODY class=main>
<H1>Motor Control</H1>
<H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview:</H2>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In this exercise, you will learn how to
generate Pulse Width Modulation (PWM) signals using the PIC microcontroller and
to use PWM to digitally control the power to a peripheral device, like an LED or
a motor. &nbsp; You will be using a Solarobotics motor, driven by a <A
href="http://focus.ti.com/docs/prod/productfolder.jhtml?genericPartNumber=SN754410">TI
SN754410 Quad Half Bridge</A> chip. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Exercises: <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. Wire up the TI motor driver
chip to a motor and control it with 2 pushbuttons.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Write a C program for the PIC to send a
variable PWM signal to an LED. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. Generate a
variable PWM signal using the PIC's built-in CCP/PWM hardware.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. Add direction-control and
reverse-detection to the PWM program and use it to control the solarobotics
motor.
<H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Materials:</H2>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 proto board with PIC
16F877 microcontroller and 20Mhz crystal <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <A
href="http://focus.ti.com/docs/prod/productfolder.jhtml?genericPartNumber=SN754410">TI
SN754410 Quad Half Bridge</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 potentiometer
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 momentary pushbutton switches
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 LEDs <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
1K resistors <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 alligator bridge clips
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 multimeter
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 power supply
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 computer <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 EPIC programmer <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 power strip
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wire and strippers <BR><BR>
<H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Wire it up:</H2>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD class=main>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In an H-bridge circuit, the
      motor is placed at the center of an arrangement of transistors laid out in
      the shape of an "H". This allows bidirectional control of the motor by
      turning on transistors at opposite corners of the H. One pair switches
      forward current, the other reverse.
    <TD><IMG src="Motor Control_files/H-bridge.jpg"><BR>
      <CENTER>A generic H-bridge.</CENTER></TD></TR>
  <TR>
    <TD class=main width="70%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The SN754410
      chip is a little different. Instead of a whole H-bridge, it contains 4
      separate outputs, each having the schematic at right. Each output is built
      from 2 drive transistors and constitues half of an H-bridge. Since the
      chip contains 4 of them, it can be wired up for to control 2 DC motors or
      1 bipolar stepper motor. The second pair of outputs can also be wired in
      parallel with the first for higher current capacity. We'll only be using 2
      outputs, half of the chip, in this exercise. </TD>
    <TD><IMG src="Motor Control_files/SN754410_one_output.jpg"><BR>
      <CENTER>One output on the SN754410.</CENTER></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD width="30%"><IMG
      src="Motor Control_files/SN754410_logic.jpg"><BR>Logic diagram of the
      SN754410. Each pair of outputs has an Enable input.</TD>
    <TD class=main width="70%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note the 2
      diodes in the output circuit above. These are a vital component in an
      H-bridge or any motor-control application. These diodes are wired in
      parallel with the drive transistors to ensure that any switching
      transients generated by the motor coils or voltage generated by the
      spinning motor don't damage the transistors.
      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The 4 outputs are grouped into pairs,
      each with an Enable (En) control pin. When +5V is applied to pin 1,2En,
      outputs 1 and 2 are activated. When 1,2En receives 0V, outputs 1 and 2 are
      "tristated," switched off just as though they were disconnected by a
      physical switch. </TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD class=main>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wire up the TI driver chip
      as illustrated. The pushbuttons deliver +5V to the chip's inputs when
      depressed. When they're released, 1K-Ohm "pulldown" resistors ensure that
      the inputs get 0V and aren't left floating. As long as 1,2En receives +5V,
      outputs 1 and 2 are always on. In this configuration, pressing one button
      or the other will drive the motor either forward or backward. But if the
      buttons have the same state, no current will flow because both sides of
      the motor will receive the same voltage.</TD>
    <TD><IMG src="Motor Control_files/ButtonHookup.jpg"><BR>
      <CENTER>Wiring diagram for manual control of the
  motor.</CENTER></TD></TR></TBODY></TABLE>
<H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. Roll your own PWM:</H2>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD class=main width="60%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PWM, Pulse Width
      Modulation, involves taking a square wave and, without changing the
      frequency, changing how long in each cycle the wave spends high and low.
      The ratio of t-high/t-low is the signal's <B>duty cycle</B>. The higher
      the duty cycle, the higher the average voltage on the signal line and the
      higher the power the signal delivers.
    <TD><IMG src="Motor Control_files/PWM_diagram.jpg"><BR>
      <CENTER>Low power (top) and high power (bottom) PWM
  waveforms.</CENTER></TD></TR></TBODY></TABLE><BR>
<TABLE width="90%">
  <TBODY>
  <TR>
    <TD class=main vAlign=top width="40%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The
      easiest way to program a PWM signal is to pick some period, T1, for our
      square wave, take an ouput pin high, delay for a time T2 (where T2&lt;T1),
      then take the output pin low and delay for a time T1-T2. By varying T2, we
      can change the duty cycle without changing the wave's frequency.
      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Since the read_ADC() function returns
      an 8-bit integer, if we use T1=255us (microseconds), we can use the analog
      value returned by read_ADC for our T2. Since the value returned by
      read_ADC() will vary between 0 and 255, T1 will stay constant:
      T1=read_ADC() + (255-read_ADC()). This will let us control the duty cycle
      of our PWM signal with an analog signal. The following program changes an
      LED's brightness based on the position of a potentiometer.
      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The LED's anode (positive termnial,
      longer lead) should be attached to Pin A1. The LED's cathode should be
      grounded through a 1k-Ohm current-limiting resistor. The potentiometer's
      center lead should attach to Pin A0 and the other 2 leads should go to +5V
      and ground. </TD></TR></TBODY></TABLE>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD class=code><BR>#include &lt;16F877.h&gt; <BR>#fuses HS,NOPROTECT,NOWDT
      //Set chip configuration.<BR>#use delay(clock=20000000) //Tell the
      compiler we're using a 20Mhz crystal.<BR>#bit LEDPin = 5.1 //Place the
      1-bit variable LED at byte 5, bit 1 of memory.<BR>#use rs232(baud=115200,
      xmit=PIN_A2, rcv=pin_A4,invert) //setup serial.<BR>void main(){
      <BR>&nbsp;&nbsp;&nbsp; int T2=0; //Local variables must be declared up
      front. Remember this is C, NOT C++. <BR>&nbsp;&nbsp;&nbsp;
      set_tris_a(0b00010001); //make only pins A0 and A4 inputs. 1=input,
      0=output. <BR><BR>&nbsp;&nbsp;&nbsp; //ADCs MUST be set up first.
      Otherwise, nothing will WORK. <BR>&nbsp;&nbsp;&nbsp; //Which pins should
      be analog? If ADCs unused, call with NO_ANALOGS. <BR>&nbsp;&nbsp;&nbsp;
      setup_ADC_ports(RA0_ANALOG); //Make PIN_A0 the only analog input.
      <BR>&nbsp;&nbsp;&nbsp; //Set the clock source for the ADC. Call with
      ADC_OFF if ADCs are unused. <BR>&nbsp;&nbsp;&nbsp;
      setup_ADC(ADC_CLOCK_INTERNAL); //Use the PIC's internal RC oscillator.
      <BR>&nbsp;&nbsp;&nbsp; set_ADC_channel(0); //Which pin to read from? In
      this case, AN0, aka PIN_A0. <BR><BR>&nbsp;&nbsp;&nbsp; while(true){
      //Start infinite loop. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      T2=read_ADC(); //store analog value in T2. This will set the duty cycle.
      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEDPin = 1; //Take PIN_A1 high,
      turning the LED on. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay_us(T2);
      //LED on-time based on ADC value. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      LEDPin = 0; //Take PIN_A1 low after T2 microcesonds, turning off LED.
      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay_us(255-T2); //LED off-time
      based on 255-ADC value, keeping T1=255.
      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE: delay_us accepts
      variable int8 arguments but only <B>const</B> longs.
      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("The input value is:
      %u\r\n", T2); //Send serial data to the PC. <BR>&nbsp;&nbsp;&nbsp; }
    <BR>}</TD></TR></TBODY></TABLE>
<CENTER></CENTER><BR><BR>
<H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. Light weight
PWM:</H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We can also generate a PWM waveform
using a piece of peripheral hardware on the PIC chip called a
Capture/Compare/PWM, or CCP unit. The PIC's CCP units (the 877 has 2, located on
pins C1 and C2) make use of the chip's internal timers to provide several useful
functions. In the case of PWM, the CCPs make use of the 8-bit timer, Timer 2.
The configuration of Timer 2 determines the frequency of the PWM signal.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Once the CCPs are set up with <FONT
face=Helvetica>setup_CCPx(CCP_PWM)</FONT> and Timer 2 is configured, you can
call <FONT face=Helvetica>set_pwmX_duty(int duty_cycle)</FONT> ("X" can be
either a 1 or a 2) at any time to set the duty cycle generated by the CCP unit.
The CCP unit constantly compares duty_cycle against the current value of Timer
2. If duty_cycle &gt;= Timer 2, the CCP sets its pin high. Otherwise, it takes
its output pin low. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Using the built-in CCP
hardware, the PIC can generate 2 PWM signals at once without interrupting
program flow except to change the duty cycle. Note that, just to be confusing,
CCP1 is located on pin C2 and CCP2 is on pin C1. This makes it easy to swap your
PWM lines, so be careful. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In the program
below, CCP2 was used to generate the PWM signal. Attach a second current-limited
LED to Pin C1. Leave the first LED on Pin A1. This pin will receive a 20Hz
"heartbeat" signal from the program's main loop. Inserting heartbeat signals
into your loops is a good debugging tool. If you use a different pin for each
loop and your program is hanging up, you can tell which loop it's stuck in by
simply probing the heartbeat pins for activity. The heartbeat on A1 in this
program has been slowed down to 20hz to make it visible.
<H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. PWM and Motor
Control:</H2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If we want the motor to be able to
turn both directions (bidirectional control), we'll need to add 3 new features
to the program from Exercise 2. First, we need to change the way that read_ADC()
maps into T2. The motor should stop when the potentiometer is centered and go
full speed when it is at either extreme. So T2 will have to vary from 255 at
read_ADC()=0 to T2=0 at read_ADC()=127, and back up to T2=255 at read_ADC()=255.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Second, we need to create 2 direction control
outputs to tell the SN754410 which way to drive the motor. The program can
decide whether to turn the motor forward or backward using: <FONT
face=Helvetica>if(127&lt;read_ADC())</FONT>. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
The third feature we need to add is reversal-detection. When the motor changes
direction, say from forward to reverse, the H-bridge turns off the 2 forward
transistors and turns on the 2 reverse transistors. The transistors don't turn
off instantly though, so if the reversal is done too quickly it's possible to
turn on the pair of reverse transistors while the forward pair is still
partially conducting. This will let current bypass the motor and run straight
through the H-bridge, possibly burning it out. In order to avoid this, it's
important to insert a "dead time" of at least 1 microsecond, where the motor
outputs are simply turned off, before reversing directions. </BODY></HTML>
